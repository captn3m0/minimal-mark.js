/*!***************************************************
* mark.js v9.0.0
* https://markjs.io/
* Copyright (c) 2014–2023, Julian Kühnel
* Released under the MIT license https://git.io/vwTVl
*****************************************************/
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e():"function"==typeof define&&define.amd?define(e):t.Mark=e()}(this,function(){"use strict";class t{constructor(t){
/**
       * The context of the instance. Either a DOM element, an array of DOM
       * elements, a NodeList or a selector
       * @type {HTMLElement|HTMLElement[]|NodeList|string}
       * @access protected
       */
this.ctx=t}static matches(t,e){const s="string"==typeof e?[e]:e,r=t.matches||t.matchesSelector||t.msMatchesSelector||t.mozMatchesSelector||t.oMatchesSelector||t.webkitMatchesSelector;if(r){let e=!1;return s.every(s=>!r.call(t,s)||(e=!0,!1)),e}// may be false e.g. when el is a textNode
return!1}
/**
     * Returns all contexts filtered by duplicates (even nested)
     * @return {HTMLElement[]} - An array containing DOM contexts
     * @access protected
     */getContexts(){let t,e=[];
// filter duplicate text nodes
return(t=void 0!==this.ctx&&this.ctx?NodeList.prototype.isPrototypeOf(this.ctx)?Array.prototype.slice.call(this.ctx):Array.isArray(this.ctx)?this.ctx:"string"==typeof this.ctx?Array.prototype.slice.call(document.querySelectorAll(this.ctx)):[this.ctx]:[]).forEach(t=>{const s=e.filter(e=>e.contains(t)).length>0;-1!==e.indexOf(t)||s||e.push(t)}),e}
/**
     * Creates a NodeIterator on the specified context
     * @see {@link https://developer.mozilla.org/en/docs/Web/API/NodeIterator}
     * @param {HTMLElement} ctx - The context DOM element
     * @param {DOMIterator~whatToShow} whatToShow
     * @param {DOMIterator~filterCb} filter
     * @return {NodeIterator}
     * @access protected
     */createIterator(t,e,s){return document.createNodeIterator(t,e,s,!1)}
/**
     * @typedef {DOMIterator~getIteratorNodeReturn}
     * @type {object.<string>}
     * @property {HTMLElement} prevNode - The previous node or null if there is
     * no
     * @property {HTMLElement} node - The current node
     */
/**
     * Returns the previous and current node of the specified iterator
     * @param {NodeIterator} itr - The iterator
     * @return {DOMIterator~getIteratorNodeReturn}
     * @access protected
     */getIteratorNode(t){const e=t.previousNode();let s;return{prevNode:e,node:s=null===e?t.nextNode():t.nextNode()&&t.nextNode()}}
/**
     * Iterates through all nodes in the specified context and handles iframe
     * nodes at the correct position
     * @param {DOMIterator~whatToShow} whatToShow
     * @param {HTMLElement} ctx - The context
     * @param  {DOMIterator~forEachNodeCallback} eachCb - Each callback
     * @param {DOMIterator~filterCb} filterCb - Filter callback
     * @param {DOMIterator~forEachNodeEndCallback} doneCb - End callback
     * @access protected
     */iterateThroughNodes(t,e,s,r,o){const n=this.createIterator(e,t,r);let i,a,h=[],l=()=>(({prevNode:a,node:i}=this.getIteratorNode(n)),i);for(;l();)
// it's faster to call the each callback in an array loop
// than in this while loop
h.push(i);h.forEach(t=>{s(t)}),o()}
/**
     * Callback for each node
     * @callback DOMIterator~forEachNodeCallback
     * @param {HTMLElement} node - The DOM text node element
     */
/**
     * Callback if all contexts were handled
     * @callback DOMIterator~forEachNodeEndCallback
     */
/**
     * Iterates over all contexts and initializes
     * {@link DOMIterator#iterateThroughNodes iterateThroughNodes} on them
     * @param {DOMIterator~whatToShow} whatToShow
     * @param  {DOMIterator~forEachNodeCallback} each - Each callback
     * @param {DOMIterator~filterCb} filter - Filter callback
     * @param {DOMIterator~forEachNodeEndCallback} done - End callback
     * @access public
     */forEachNode(t,e,s,r=(()=>{})){const o=this.getContexts();let n=o.length;n||r(),o.forEach(o=>{
// wait for iframes to avoid recursive calls, otherwise this would
// perhaps reach the recursive function call limit with many nodes
(()=>{this.iterateThroughNodes(t,o,e,s,()=>{--n<=0&&// call end all contexts were handled
r()})})()})}
/**
     * Callback to filter nodes. Can return e.g. NodeFilter.FILTER_ACCEPT or
     * NodeFilter.FILTER_REJECT
     * @see {@link http://tinyurl.com/zdczmm2}
     * @callback DOMIterator~filterCb
     * @param {HTMLElement} node - The node to filter
     */
/**
     * @typedef DOMIterator~whatToShow
     * @see {@link http://tinyurl.com/zfqqkx2}
     * @type {number}
     */}class e{constructor(t){this.opt=Object.assign({},{
// 'diacritics': false,
// 'synonyms': {},
// 'accuracy': 'exactly',
caseSensitive:!1},t)}create(t){return t=this.escapeStr(t),t=this.createMergedBlanksRegExp(t),t=this.createAccuracyRegExp(t),new RegExp(t,`gm${this.opt.caseSensitive?"":"i"}`)}sortByLength(t){return t.sort((t,e)=>t.length===e.length?
// sort a-z for same length elements
t>e?1:-1:e.length-t.length)}escapeStr(t){
// eslint-disable-next-line no-useless-escape
return t.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g,"\\$&")}createMergedBlanksRegExp(t){return t.replace(/[\s]+/gim,"[\\s]+")}createAccuracyRegExp(t){return`(^|\\s)(${t})(?=$|\\s)`}}
/**
   * Marks search terms in DOM elements
   * @example
   * new Mark(document.querySelector('.context')).mark('lorem ipsum');
   * @example
   * new Mark(document.querySelector('.context')).markRegExp(/lorem/gmi);
   * @example
   * new Mark('.context').markRanges([{start:10,length:0}]);
   */class s{
/**
     * @param {HTMLElement|HTMLElement[]|NodeList|string} ctx - The context DOM
     * element, an array of DOM elements, a NodeList or a selector
     */
constructor(t){
/**
       * The context of the instance. Either a DOM element, an array of DOM
       * elements, a NodeList or a selector
       * @type {HTMLElement|HTMLElement[]|NodeList|string}
       * @access protected
       */
this.ctx=t,
/**
       * Specifies if the current browser is a IE (necessary for the node
       * normalization bug workaround). See {@link Mark#unwrapMatches}
       * @type {boolean}
       * @access protected
       */
this.ie=!1;const e=window.navigator.userAgent;(e.indexOf("MSIE")>-1||e.indexOf("Trident")>-1)&&(this.ie=!0)}
/**
     * Options defined by the user. They will be initialized from one of the
     * public methods. See {@link Mark#mark}, {@link Mark#markRegExp},
     * {@link Mark#markRanges} and {@link Mark#unmark} for option properties.
     * @type {object}
     * @param {object} [val] - An object that will be merged with defaults
     * @access protected
     */set opt(t){this._opt=Object.assign({},{element:"",className:"",exclude:[],iframes:!1,iframesTimeout:5e3,separateWordSearch:!0,acrossElements:!1,ignoreGroups:0,each:()=>{},noMatch:()=>{},filter:()=>!0,done:()=>{},debug:!1,log:window.console},t)}get opt(){return this._opt}
/**
     * An instance of DOMIterator
     * @type {DOMIterator}
     * @access protected
     */get iterator(){
// always return new instance in case there were option changes
return new t(this.ctx)}
/**
     * Logs a message if log is enabled
     * @param {string} msg - The message to log
     * @param {string} [level="debug"] - The log level, e.g. <code>warn</code>
     * <code>error</code>, <code>debug</code>
     * @access protected
     */log(t,e="debug"){const s=this.opt.log;this.opt.debug&&"object"==typeof s&&"function"==typeof s[e]&&s[e](`mark.js: ${t}`)}
/**
     * @typedef Mark~separatedKeywords
     * @type {object.<string>}
     * @property {array.<string>} keywords - The list of keywords
     * @property {number} length - The length
     */
/**
     * Returns a list of keywords dependent on whether separate word search
     * was defined. Also it filters empty keywords
     * @param {array} sv - The array of keywords
     * @return {Mark~separatedKeywords}
     * @access protected
     */getSeparatedKeywords(t){let e=[];return t.forEach(t=>{this.opt.separateWordSearch?t.split(" ").forEach(t=>{t.trim()&&-1===e.indexOf(t)&&e.push(t)}):t.trim()&&-1===e.indexOf(t)&&e.push(t)}),{
// sort because of https://git.io/v6USg
keywords:e.sort((t,e)=>e.length-t.length),length:e.length}}
/**
     * Check if a value is a number
     * @param {number|string} value - the value to check;
     * numeric strings allowed
     * @return {boolean}
     * @access protected
     */isNumeric(t){
// http://stackoverflow.com/a/16655847/145346
// eslint-disable-next-line eqeqeq
return Number(parseFloat(t))==t}
/**
     * @typedef Mark~rangeObject
     * @type {object}
     * @property {number} start - The start position within the composite value
     * @property {number} length - The length of the string to mark within the
     * composite value.
     */
/**
     * @typedef Mark~setOfRanges
     * @type {object[]}
     * @property {Mark~rangeObject}
     */
/**
     * Returns a processed list of integer offset indexes that do not overlap
     * each other, and remove any string values or additional elements
     * @param {Mark~setOfRanges} array - unprocessed raw array
     * @return {Mark~setOfRanges} - processed array with any invalid entries
     * removed
     * @throws Will throw an error if an array of objects is not passed
     * @access protected
     */checkRanges(t){
// start and length indexes are included in an array of objects
// [{start: 0, length: 1}, {start: 4, length: 5}]
// quick validity check of the first entry only
if(!Array.isArray(t)||"[object Object]"!==Object.prototype.toString.call(t[0]))return this.log("markRanges() will only accept an array of objects"),this.opt.noMatch(t),[];const e=[];let s=0;return t.sort((t,e)=>t.start-e.start).forEach(t=>{let{start:r,end:o,valid:n}=this.callNoMatchOnInvalidRanges(t,s);n&&(
// preserve item in case there are extra key:values within
t.start=r,t.length=o-r,e.push(t),s=o)}),e}
/**
     * @typedef Mark~validObject
     * @type {object}
     * @property {number} start - The start position within the composite value
     * @property {number} end - The calculated end position within the composite
     * value.
     * @property {boolean} valid - boolean value indicating that the start and
     * calculated end range is valid
     */
/**
     * Initial validation of ranges for markRanges. Preliminary checks are done
     * to ensure the start and length values exist and are not zero or non-
     * numeric
     * @param {Mark~rangeObject} range - the current range object
     * @param {number} last - last index of range
     * @return {Mark~validObject}
     * @access protected
     */callNoMatchOnInvalidRanges(t,e){let s,r,o=!1;return t&&void 0!==t.start?(r=(s=parseInt(t.start,10))+parseInt(t.length,10),
// ignore overlapping values & non-numeric entries
this.isNumeric(t.start)&&this.isNumeric(t.length)&&r-e>0&&r-s>0?o=!0:(this.log("Ignoring invalid or overlapping range: "+`${JSON.stringify(t)}`),this.opt.noMatch(t))):(this.log(`Ignoring invalid range: ${JSON.stringify(t)}`),this.opt.noMatch(t)),{start:s,end:r,valid:o}}
/**
     * Check valid range for markRanges. Check ranges with access to the context
     * string. Range values are double checked, lengths that extend the mark
     * beyond the string length are limitied and ranges containing only
     * whitespace are ignored
     * @param {Mark~rangeObject} range - the current range object
     * @param {number} originalLength - original length of the context string
     * @param {string} string - current content string
     * @return {Mark~validObject}
     * @access protected
     */checkWhitespaceRanges(t,e,s){let r,o=!0,
// the max value changes after the DOM is manipulated
n=s.length,
// adjust offset to account for wrapped text node
i=e-n,a=parseInt(t.start,10)-i;
// make sure to stop at max
return(r=(a=a>n?n:a)+parseInt(t.length,10))>n&&(r=n,this.log(`End range automatically set to the max value of ${n}`)),a<0||r-a<0||a>n||r>n?(o=!1,this.log(`Invalid range: ${JSON.stringify(t)}`),this.opt.noMatch(t)):""===s.substring(a,r).replace(/\s+/g,"")&&(o=!1,
// whitespace only; even if wrapped it is not visible
this.log("Skipping whitespace only range: "+JSON.stringify(t)),this.opt.noMatch(t)),{start:a,end:r,valid:o}}
/**
     * @typedef Mark~getTextNodesDict
     * @type {object.<string>}
     * @property {string} value - The composite value of all text nodes
     * @property {object[]} nodes - An array of objects
     * @property {number} nodes.start - The start position within the composite
     * value
     * @property {number} nodes.end - The end position within the composite
     * value
     * @property {HTMLElement} nodes.node - The DOM text node element
     */
/**
     * Callback
     * @callback Mark~getTextNodesCallback
     * @param {Mark~getTextNodesDict}
     */
/**
     * Calls the callback with an object containing all text nodes (including
     * iframe text nodes) with start and end positions and the composite value
     * of them (string)
     * @param {Mark~getTextNodesCallback} cb - Callback
     * @access protected
     */getTextNodes(t){let e="",s=[];this.iterator.forEachNode(NodeFilter.SHOW_TEXT,t=>{s.push({start:e.length,end:(e+=t.textContent).length,node:t})},t=>this.matchesExclude(t.parentNode)?NodeFilter.FILTER_REJECT:NodeFilter.FILTER_ACCEPT,()=>{t({value:e,nodes:s})})}
/**
     * Checks if an element matches any of the specified exclude selectors. Also
     * it checks for elements in which no marks should be performed (e.g.
     * script and style tags) and optionally already marked elements
     * @param  {HTMLElement} el - The element to check
     * @return {boolean}
     * @access protected
     */matchesExclude(e){return t.matches(e,this.opt.exclude.concat([
// ignores the elements itself, not their childrens (selector *)
"script","style","title","head","html"]))}
/**
     * Wraps the instance element and class around matches that fit the start and
     * end positions within the node
     * @param  {HTMLElement} node - The DOM text node
     * @param  {number} start - The position where to start wrapping
     * @param  {number} end - The position where to end wrapping
     * @return {HTMLElement} Returns the splitted text node that will appear
     * after the wrapped text node
     * @access protected
     */wrapRangeInTextNode(t,e,s){const r=this.opt.element?this.opt.element:"mark",o=t.splitText(e),n=o.splitText(s-e);let i=document.createElement(r);return i.setAttribute("data-markjs","true"),this.opt.className&&i.setAttribute("class",this.opt.className),i.textContent=o.textContent,o.parentNode.replaceChild(i,o),n}
/**
     * @typedef Mark~wrapRangeInMappedTextNodeDict
     * @type {object.<string>}
     * @property {string} value - The composite value of all text nodes
     * @property {object[]} nodes - An array of objects
     * @property {number} nodes.start - The start position within the composite
     * value
     * @property {number} nodes.end - The end position within the composite
     * value
     * @property {HTMLElement} nodes.node - The DOM text node element
     */
/**
     * Each callback
     * @callback Mark~wrapMatchesEachCallback
     * @param {HTMLElement} node - The wrapped DOM element
     * @param {number} lastIndex - The last matching position within the
     * composite value of text nodes
     */
/**
     * Filter callback
     * @callback Mark~wrapMatchesFilterCallback
     * @param {HTMLElement} node - The matching text node DOM element
     */
/**
     * Determines matches by start and end positions using the text node
     * dictionary even across text nodes and calls
     * {@link Mark#wrapRangeInTextNode} to wrap them
     * @param  {Mark~wrapRangeInMappedTextNodeDict} dict - The dictionary
     * @param  {number} start - The start position of the match
     * @param  {number} end - The end position of the match
     * @param  {Mark~wrapMatchesFilterCallback} filterCb - Filter callback
     * @param  {Mark~wrapMatchesEachCallback} eachCb - Each callback
     * @access protected
     */wrapRangeInMappedTextNode(t,e,s,r,o){
// iterate over all text nodes to find the one matching the positions
t.nodes.every((n,i)=>{const a=t.nodes[i+1];if(void 0===a||a.start>e){if(!r(n.node))return!1;
// map range from dict.value to text node
const a=e-n.start,h=(s>n.end?n.end:s)-n.start,l=t.value.substr(0,n.start),c=t.value.substr(h+n.start);if(n.node=this.wrapRangeInTextNode(n.node,a,h),
// recalculate positions to also find subsequent matches in the
// same text node. Necessary as the text node in dict now only
// contains the splitted part after the wrapped one
t.value=l+c,t.nodes.forEach((e,s)=>{s>=i&&(t.nodes[s].start>0&&s!==i&&(t.nodes[s].start-=h),t.nodes[s].end-=h)}),s-=h,o(n.node.previousSibling,n.start),!(s>n.end))return!1;e=n.end}return!0})}
/**
    * @param {HTMLElement} node - The text node where the match occurs
    * @param {number} pos - The current position of the match within the node
    * @param {number} len - The length of the current match within the node
    * @param {Mark~wrapMatchesEachCallback} eachCb
    */wrapGroups(t,e,s,r){return r((t=this.wrapRangeInTextNode(t,e,e+s)).previousSibling),t}
/**
     * Separate groups
     * @param {HTMLElement} node - The text node where the match occurs
     * @param {array} match - The current match
     * @param {number} matchIdx - The start of the match based on ignoreGroups
     * @param {Mark~wrapMatchesFilterCallback} filterCb
     * @param {Mark~wrapMatchesEachCallback} eachCb
     */separateGroups(t,e,s,r,o){let n=e.length;for(let s=1;s<n;s++){let n=t.textContent.indexOf(e[s]);e[s]&&n>-1&&r(e[s],t)&&(t=this.wrapGroups(t,n,e[s].length,o))}return t}
/**
     * Filter callback before each wrapping
     * @callback Mark~wrapMatchesFilterCallback
     * @param {string} match - The matching string
     * @param {HTMLElement} node - The text node where the match occurs
     */
/**
     * Callback for each wrapped element
     * @callback Mark~wrapMatchesEachCallback
     * @param {HTMLElement} element - The marked DOM element
     */
/**
     * Callback on end
     * @callback Mark~wrapMatchesEndCallback
     */
/**
     * Wraps the instance element and class around matches within single HTML
     * elements in all contexts
     * @param {RegExp} regex - The regular expression to be searched for
     * @param {number} ignoreGroups - A number indicating the amount of RegExp
     * matching groups to ignore
     * @param {Mark~wrapMatchesFilterCallback} filterCb
     * @param {Mark~wrapMatchesEachCallback} eachCb
     * @param {Mark~wrapMatchesEndCallback} endCb
     * @access protected
     */wrapMatches(t,e,s,r,o){const n=0===e?0:e+1;this.getTextNodes(e=>{e.nodes.forEach(e=>{let o;for(e=e.node;null!==(o=t.exec(e.textContent))&&""!==o[n];){if(this.opt.separateGroups&&1!==o.length)e=this.separateGroups(e,o,n,s,r);else{if(!s(o[n],e))continue;let t=o.index;if(0!==n)for(let e=1;e<n;e++)t+=o[e].length;e=this.wrapGroups(e,t,o[n].length,r)}
// reset index of last match as the node changed and the
// index isn't valid anymore http://tinyurl.com/htsudjd
t.lastIndex=0}}),o()})}
/**
     * Callback for each wrapped element
     * @callback Mark~wrapMatchesAcrossElementsEachCallback
     * @param {HTMLElement} element - The marked DOM element
     */
/**
     * Filter callback before each wrapping
     * @callback Mark~wrapMatchesAcrossElementsFilterCallback
     * @param {string} match - The matching string
     * @param {HTMLElement} node - The text node where the match occurs
     */
/**
     * Callback on end
     * @callback Mark~wrapMatchesAcrossElementsEndCallback
     */
/**
     * Wraps the instance element and class around matches across all HTML
     * elements in all contexts
     * @param {RegExp} regex - The regular expression to be searched for
     * @param {number} ignoreGroups - A number indicating the amount of RegExp
     * matching groups to ignore
     * @param {Mark~wrapMatchesAcrossElementsFilterCallback} filterCb
     * @param {Mark~wrapMatchesAcrossElementsEachCallback} eachCb
     * @param {Mark~wrapMatchesAcrossElementsEndCallback} endCb
     * @access protected
     */wrapMatchesAcrossElements(t,e,s,r,o){const n=0===e?0:e+1;this.getTextNodes(e=>{let i;for(;null!==(i=t.exec(e.value))&&""!==i[n];){
// calculate range inside dict.value
let o=i.index;if(0!==n)for(let t=1;t<n;t++)o+=i[t].length;const a=o+i[n].length;
// note that dict will be updated automatically, as it'll change
// in the wrapping process, due to the fact that text
// nodes will be splitted
this.wrapRangeInMappedTextNode(e,o,a,t=>s(i[n],t),(e,s)=>{t.lastIndex=s,r(e)})}o()})}
/**
     * Callback for each wrapped element
     * @callback Mark~wrapRangeFromIndexEachCallback
     * @param {HTMLElement} element - The marked DOM element
     * @param {Mark~rangeObject} range - the current range object; provided
     * start and length values will be numeric integers modified from the
     * provided original ranges.
     */
/**
     * Filter callback before each wrapping
     * @callback Mark~wrapRangeFromIndexFilterCallback
     * @param {HTMLElement} node - The text node which includes the range
     * @param {Mark~rangeObject} range - the current range object
     * @param {string} match - string extracted from the matching range
     * @param {number} counter - A counter indicating the number of all marks
     */
/**
     * Callback on end
     * @callback Mark~wrapRangeFromIndexEndCallback
     */
/**
     * Wraps the indicated ranges across all HTML elements in all contexts
     * @param {Mark~setOfRanges} ranges
     * @param {Mark~wrapRangeFromIndexFilterCallback} filterCb
     * @param {Mark~wrapRangeFromIndexEachCallback} eachCb
     * @param {Mark~wrapRangeFromIndexEndCallback} endCb
     * @access protected
     */wrapRangeFromIndex(t,e,s,r){this.getTextNodes(o=>{const n=o.value.length;t.forEach((t,r)=>{let{start:i,end:a,valid:h}=this.checkWhitespaceRanges(t,n,o.value);h&&this.wrapRangeInMappedTextNode(o,i,a,s=>e(s,t,o.value.substring(i,a),r),e=>{s(e,t)})}),r()})}
/**
     * Unwraps the specified DOM node with its content (text nodes or HTML)
     * without destroying possibly present events (using innerHTML) and normalizes
     * the parent at the end (merge splitted text nodes)
     * @param  {HTMLElement} node - The DOM node to unwrap
     * @access protected
     */unwrapMatches(t){const e=t.parentNode;let s=document.createDocumentFragment();for(;t.firstChild;)s.appendChild(t.removeChild(t.firstChild));e.replaceChild(s,t),this.ie?// custom method (needs more time)
this.normalizeTextNode(e):// use browser's normalize method
e.normalize()}
/**
     * Normalizes text nodes. It's a workaround for the native normalize method
     * that has a bug in IE (see attached link). Should only be used in IE
     * browsers as it's slower than the native method.
     * @see {@link http://tinyurl.com/z5asa8c}
     * @param {HTMLElement} node - The DOM node to normalize
     * @access protected
     */normalizeTextNode(t){if(t){if(3===t.nodeType)for(;t.nextSibling&&3===t.nextSibling.nodeType;)t.nodeValue+=t.nextSibling.nodeValue,t.parentNode.removeChild(t.nextSibling);else this.normalizeTextNode(t.firstChild);this.normalizeTextNode(t.nextSibling)}}
/**
     * Callback for each marked element
     * @callback Mark~markEachCallback
     * @param {HTMLElement} element - The marked DOM element
     */
/**
     * Callback if there were no matches
     * @callback Mark~markNoMatchCallback
     * @param {RegExp} term - The search term that was not found
     */
/**
     * Callback when finished
     * @callback Mark~commonDoneCallback
     * @param {number} totalMatches - The number of marked elements
     */
/**
     * @typedef Mark~commonOptions
     * @type {object.<string>}
     * @property {string} [element="mark"] - HTML element tag name
     * @property {string} [className] - An optional class name
     * @property {string[]} [exclude] - An array with exclusion selectors.
     * Elements matching those selectors will be ignored
     * @property {boolean} [iframes=false] - Whether to search inside iframes
     * @property {number} [iframesTimeout=5000] - Maximum ms to wait for a load
     * event of an iframe
     * @property {boolean} [acrossElements=false] - Whether to find matches
     * across HTML elements. By default, only matches within single HTML
     * elements will be found
     * @property {Mark~markEachCallback} [each]
     * @property {Mark~markNoMatchCallback} [noMatch]
     * @property {Mark~commonDoneCallback} [done]
     * @property {boolean} [debug=false] - Whether to log messages
     * @property {object} [log=window.console] - Where to log messages (only if
     * debug is true)
     */
/**
     * Callback if there were no matches
     * @callback Mark~markRegExpNoMatchCallback
     * @param {RegExp} regexp - The regular expression
     */
/**
     * Callback to filter matches
     * @callback Mark~markRegExpFilterCallback
     * @param {HTMLElement} textNode - The text node which includes the match
     * @param {string} match - The matching string for the RegExp
     * @param {number} counter - A counter indicating the number of all marks
     */
/**
     * These options also include the common options from
     * {@link Mark~commonOptions}
     * @typedef Mark~markRegExpOptions
     * @type {object.<string>}
     * @property {number} [ignoreGroups=0] - A number indicating the amount of
     * RegExp matching groups to ignore
     * @property {boolean} [separateGroups] - Whether to mark each regular
     * expression group as a separate match
     * @property {Mark~markRegExpNoMatchCallback} [noMatch]
     * @property {Mark~markRegExpFilterCallback} [filter]
     */
/**
     * Marks a custom regular expression
     * @param  {RegExp} regexp - The regular expression
     * @param  {Mark~markRegExpOptions} [opt] - Optional options object
     * @access public
     */markRegExp(t,e){this.opt=e,this.log(`Searching with expression "${t}"`);let s=0,r="wrapMatches";this.opt.acrossElements&&(r="wrapMatchesAcrossElements"),this[r](t,this.opt.ignoreGroups,(t,e)=>this.opt.filter(e,t,s),t=>{s++,this.opt.each(t)},()=>{0===s&&this.opt.noMatch(t),this.opt.done(s)})}
/**
     * Callback to filter matches
     * @callback Mark~markFilterCallback
     * @param {HTMLElement} textNode - The text node which includes the match
     * @param {string} match - The matching term
     * @param {number} totalCounter - A counter indicating the number of all
     * marks
     * @param {number} termCounter - A counter indicating the number of marks
     * for the specific match
     */
/**
     * These options also include the common options from
     * {@link Mark~commonOptions} and the options from
     * {@link RegExpCreator~options}
     * @typedef Mark~markOptions
     * @type {object.<string>}
     * @property {boolean} [separateWordSearch=true] - Whether to search for
     * each word separated by a blank instead of the complete term
     * @property {Mark~markFilterCallback} [filter]
     */
/**
     * Marks the specified search terms
     * @param {string|string[]} [sv] - Search value, either a search string or an
     * array containing multiple search strings
     * @param  {Mark~markOptions} [opt] - Optional options object
     * @access public
     */mark(t,s){this.opt=s;let r=0,o="wrapMatches";const{keywords:n,length:i}=this.getSeparatedKeywords("string"==typeof t?[t]:t),a=t=>{// async function calls as iframes are async too
const s=new e(this.opt).create(t);let h=0;this.log(`Searching with expression "${s}"`),this[o](s,1,(e,s)=>this.opt.filter(s,t,r,h),t=>{h++,r++,this.opt.each(t)},()=>{0===h&&this.opt.noMatch(t),n[i-1]===t?this.opt.done(r):a(n[n.indexOf(t)+1])})};this.opt.acrossElements&&(o="wrapMatchesAcrossElements"),0===i?this.opt.done(r):a(n[0])}
/**
     * Callback for each marked element
     * @callback Mark~markRangesEachCallback
     * @param {HTMLElement} element - The marked DOM element
     * @param {array} range - array of range start and end points
     */
/**
     * Callback if a processed range is invalid, out-of-bounds, overlaps another
     * range, or only matches whitespace
     * @callback Mark~markRangesNoMatchCallback
     * @param {Mark~rangeObject} range - a range object
     */
/**
     * Callback to filter matches
     * @callback Mark~markRangesFilterCallback
     * @param {HTMLElement} node - The text node which includes the range
     * @param {array} range - array of range start and end points
     * @param {string} match - string extracted from the matching range
     * @param {number} counter - A counter indicating the number of all marks
     */
/**
     * These options also include the common options from
     * {@link Mark~commonOptions} without the each and noMatch callback
     * @typedef Mark~markRangesOptions
     * @type {object.<string>}
     * @property {Mark~markRangesEachCallback} [each]
     * @property {Mark~markRangesNoMatchCallback} [noMatch]
     * @property {Mark~markRangesFilterCallback} [filter]
     */
/**
     * Marks an array of objects containing a start with an end or length of the
     * string to mark
     * @param  {Mark~setOfRanges} rawRanges - The original (preprocessed)
     * array of objects
     * @param  {Mark~markRangesOptions} [opt] - Optional options object
     * @access public
     */markRanges(t,e){this.opt=e;let s=0,r=this.checkRanges(t);r&&r.length?(this.log("Starting to mark with the following ranges: "+JSON.stringify(r)),this.wrapRangeFromIndex(r,(t,e,s,r)=>this.opt.filter(t,e,s,r),(t,e)=>{s++,this.opt.each(t,e)},()=>{this.opt.done(s)})):this.opt.done(s)}
/**
     * Removes all marked elements inside the context with their HTML and
     * normalizes the parent at the end
     * @param  {Mark~commonOptions} [opt] - Optional options object without each,
     * noMatch and acrossElements properties
     * @access public
     */unmark(e){this.opt=e;let s=this.opt.element?this.opt.element:"*";s+="[data-markjs]",this.opt.className&&(s+=`.${this.opt.className}`),this.log(`Removal selector "${s}"`),this.iterator.forEachNode(NodeFilter.SHOW_ELEMENT,t=>{this.unwrapMatches(t)},e=>{const r=t.matches(e,s),o=this.matchesExclude(e);return!r||o?NodeFilter.FILTER_REJECT:NodeFilter.FILTER_ACCEPT},this.opt.done)}}return function(t){const e=new s(t);return this.mark=((t,s)=>(e.mark(t,s),this)),this.unmark=(t=>(e.unmark(t),this)),this}});
