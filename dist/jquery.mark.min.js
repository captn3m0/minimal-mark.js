/*!***************************************************
* mark.js v9.0.0
* https://markjs.io/
* Copyright (c) 2014–2023, Julian Kühnel
* Released under the MIT license https://git.io/vwTVl
*****************************************************/
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e(require("jquery")):"function"==typeof define&&define.amd?define(["jquery"],e):t.Mark=e(t.jQuery)}(this,function(t){"use strict";function e(t){return(e="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}function n(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function r(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,(o=r.key,i=void 0,"symbol"==typeof(i=function(t,e){if("object"!=typeof t||null===t)return t;var n=t[Symbol.toPrimitive];if(void 0!==n){var r=n.call(t,e||"default");if("object"!=typeof r)return r;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===e?String:Number)(t)}(o,"string"))?i:String(i)),r)}var o,i}function o(t,e,n){return e&&r(t.prototype,e),n&&r(t,n),Object.defineProperty(t,"prototype",{writable:!1}),t}function i(){return(i=Object.assign?Object.assign.bind():function(t){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(t[r]=n[r])}return t}).apply(this,arguments)}t=t&&t.hasOwnProperty("default")?t.default:t;var a=/* */function(){function t(e){n(this,t),
/**
       * The context of the instance. Either a DOM element, an array of DOM
       * elements, a NodeList or a selector
       * @type {HTMLElement|HTMLElement[]|NodeList|string}
       * @access protected
       */
this.ctx=e}return o(t,[{key:"getContexts",value:
/**
       * Returns all contexts filtered by duplicates (even nested)
       * @return {HTMLElement[]} - An array containing DOM contexts
       * @access protected
       */
function(){var t=[];
// filter duplicate text nodes
return(void 0!==this.ctx&&this.ctx?NodeList.prototype.isPrototypeOf(this.ctx)?Array.prototype.slice.call(this.ctx):Array.isArray(this.ctx)?this.ctx:"string"==typeof this.ctx?Array.prototype.slice.call(document.querySelectorAll(this.ctx)):[this.ctx]:[]).forEach(function(e){var n=t.filter(function(t){return t.contains(e)}).length>0;-1!==t.indexOf(e)||n||t.push(e)}),t}
/**
       * Creates a NodeIterator on the specified context
       * @see {@link https://developer.mozilla.org/en/docs/Web/API/NodeIterator}
       * @param {HTMLElement} ctx - The context DOM element
       * @param {DOMIterator~whatToShow} whatToShow
       * @param {DOMIterator~filterCb} filter
       * @return {NodeIterator}
       * @access protected
       */},{key:"createIterator",value:function(t,e,n){return document.createNodeIterator(t,e,n,!1)}
/**
       * @typedef {DOMIterator~getIteratorNodeReturn}
       * @type {object.<string>}
       * @property {HTMLElement} prevNode - The previous node or null if there is
       * no
       * @property {HTMLElement} node - The current node
       */
/**
       * Returns the previous and current node of the specified iterator
       * @param {NodeIterator} itr - The iterator
       * @return {DOMIterator~getIteratorNodeReturn}
       * @access protected
       */},{key:"getIteratorNode",value:function(t){var e=t.previousNode();return{prevNode:e,node:null===e?t.nextNode():t.nextNode()&&t.nextNode()}}
/**
       * Iterates through all nodes in the specified context and handles iframe
       * nodes at the correct position
       * @param {DOMIterator~whatToShow} whatToShow
       * @param {HTMLElement} ctx - The context
       * @param  {DOMIterator~forEachNodeCallback} eachCb - Each callback
       * @param {DOMIterator~filterCb} filterCb - Filter callback
       * @param {DOMIterator~forEachNodeEndCallback} doneCb - End callback
       * @access protected
       */},{key:"iterateThroughNodes",value:function(t,e,n,r,o){for(var i,a,s=this,c=this.createIterator(e,t,r),u=[];a=void 0,a=s.getIteratorNode(c),a.prevNode,i=a.node;)
// it's faster to call the each callback in an array loop
// than in this while loop
u.push(i);u.forEach(function(t){n(t)}),o()}
/**
       * Callback for each node
       * @callback DOMIterator~forEachNodeCallback
       * @param {HTMLElement} node - The DOM text node element
       */
/**
       * Callback if all contexts were handled
       * @callback DOMIterator~forEachNodeEndCallback
       */
/**
       * Iterates over all contexts and initializes
       * {@link DOMIterator#iterateThroughNodes iterateThroughNodes} on them
       * @param {DOMIterator~whatToShow} whatToShow
       * @param  {DOMIterator~forEachNodeCallback} each - Each callback
       * @param {DOMIterator~filterCb} filter - Filter callback
       * @param {DOMIterator~forEachNodeEndCallback} done - End callback
       * @access public
       */},{key:"forEachNode",value:function(t,e,n){var r=this,o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:function(){},i=this.getContexts(),a=i.length;a||o(),i.forEach(function(i){r.iterateThroughNodes(t,i,e,n,function(){--a<=0&&
// call end all contexts were handled
o()})})}
/**
       * Callback to filter nodes. Can return e.g. NodeFilter.FILTER_ACCEPT or
       * NodeFilter.FILTER_REJECT
       * @see {@link http://tinyurl.com/zdczmm2}
       * @callback DOMIterator~filterCb
       * @param {HTMLElement} node - The node to filter
       */
/**
       * @typedef DOMIterator~whatToShow
       * @see {@link http://tinyurl.com/zfqqkx2}
       * @type {number}
       */}],[{key:"matches",value:function(t,e){var n="string"==typeof e?[e]:e,r=t.matches||t.matchesSelector||t.msMatchesSelector||t.mozMatchesSelector||t.oMatchesSelector||t.webkitMatchesSelector;if(r){var o=!1;return n.every(function(e){return!r.call(t,e)||(o=!0,!1)}),o}
// may be false e.g. when el is a textNode
return!1}}]),t}(),s=/* */function(){function t(e){n(this,t),this.opt=i({},{
// 'diacritics': false,
// 'synonyms': {},
// 'accuracy': 'exactly',
caseSensitive:!1},e)}return o(t,[{key:"create",value:function(t){return t=this.escapeStr(t),t=this.createMergedBlanksRegExp(t),t=this.createAccuracyRegExp(t),new RegExp(t,"gm".concat(this.opt.caseSensitive?"":"i"))}},{key:"sortByLength",value:function(t){return t.sort(function(t,e){return t.length===e.length?
// sort a-z for same length elements
t>e?1:-1:e.length-t.length})}},{key:"escapeStr",value:function(t){
// eslint-disable-next-line no-useless-escape
return t.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g,"\\$&")}},{key:"createMergedBlanksRegExp",value:function(t){return t.replace(/[\s]+/gim,"[\\s]+")}},{key:"createAccuracyRegExp",value:function(t){return"(^|\\s)(".concat(t,")(?=$|\\s)")}}]),t}(),c=/* */function(){
/**
     * @param {HTMLElement|HTMLElement[]|NodeList|string} ctx - The context DOM
     * element, an array of DOM elements, a NodeList or a selector
     */
function t(e){n(this,t),
/**
       * The context of the instance. Either a DOM element, an array of DOM
       * elements, a NodeList or a selector
       * @type {HTMLElement|HTMLElement[]|NodeList|string}
       * @access protected
       */
this.ctx=e,
/**
       * Specifies if the current browser is a IE (necessary for the node
       * normalization bug workaround). See {@link Mark#unwrapMatches}
       * @type {boolean}
       * @access protected
       */
this.ie=!1;var r=window.navigator.userAgent;(r.indexOf("MSIE")>-1||r.indexOf("Trident")>-1)&&(this.ie=!0)}
/**
     * Options defined by the user. They will be initialized from one of the
     * public methods. See {@link Mark#mark}, {@link Mark#markRegExp},
     * {@link Mark#markRanges} and {@link Mark#unmark} for option properties.
     * @type {object}
     * @param {object} [val] - An object that will be merged with defaults
     * @access protected
     */return o(t,[{key:"opt",get:function(){return this._opt}
/**
       * An instance of DOMIterator
       * @type {DOMIterator}
       * @access protected
       */,set:function(t){this._opt=i({},{element:"",className:"",exclude:[],iframes:!1,iframesTimeout:5e3,separateWordSearch:!0,acrossElements:!1,ignoreGroups:0,each:function(){},noMatch:function(){},filter:function(){return!0},done:function(){},debug:!1,log:window.console},t)}},{key:"iterator",get:function(){
// always return new instance in case there were option changes
return new a(this.ctx)}
/**
       * Logs a message if log is enabled
       * @param {string} msg - The message to log
       * @param {string} [level="debug"] - The log level, e.g. <code>warn</code>
       * <code>error</code>, <code>debug</code>
       * @access protected
       */},{key:"log",value:function(t){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"debug",r=this.opt.log;this.opt.debug&&"object"===e(r)&&"function"==typeof r[n]&&r[n]("mark.js: ".concat(t))}
/**
       * @typedef Mark~separatedKeywords
       * @type {object.<string>}
       * @property {array.<string>} keywords - The list of keywords
       * @property {number} length - The length
       */
/**
       * Returns a list of keywords dependent on whether separate word search
       * was defined. Also it filters empty keywords
       * @param {array} sv - The array of keywords
       * @return {Mark~separatedKeywords}
       * @access protected
       */},{key:"getSeparatedKeywords",value:function(t){var e=this,n=[];return t.forEach(function(t){e.opt.separateWordSearch?t.split(" ").forEach(function(t){t.trim()&&-1===n.indexOf(t)&&n.push(t)}):t.trim()&&-1===n.indexOf(t)&&n.push(t)}),{
// sort because of https://git.io/v6USg
keywords:n.sort(function(t,e){return e.length-t.length}),length:n.length}}
/**
       * Check if a value is a number
       * @param {number|string} value - the value to check;
       * numeric strings allowed
       * @return {boolean}
       * @access protected
       */},{key:"isNumeric",value:function(t){
// http://stackoverflow.com/a/16655847/145346
// eslint-disable-next-line eqeqeq
return Number(parseFloat(t))==t}
/**
       * @typedef Mark~rangeObject
       * @type {object}
       * @property {number} start - The start position within the composite value
       * @property {number} length - The length of the string to mark within the
       * composite value.
       */
/**
       * @typedef Mark~setOfRanges
       * @type {object[]}
       * @property {Mark~rangeObject}
       */
/**
       * Returns a processed list of integer offset indexes that do not overlap
       * each other, and remove any string values or additional elements
       * @param {Mark~setOfRanges} array - unprocessed raw array
       * @return {Mark~setOfRanges} - processed array with any invalid entries
       * removed
       * @throws Will throw an error if an array of objects is not passed
       * @access protected
       */},{key:"checkRanges",value:function(t){var e=this;
// start and length indexes are included in an array of objects
// [{start: 0, length: 1}, {start: 4, length: 5}]
// quick validity check of the first entry only
if(!Array.isArray(t)||"[object Object]"!==Object.prototype.toString.call(t[0]))return this.log("markRanges() will only accept an array of objects"),this.opt.noMatch(t),[];var n=[],r=0;return t.sort(function(t,e){return t.start-e.start}).forEach(function(t){var o=e.callNoMatchOnInvalidRanges(t,r),i=o.start,a=o.end;o.valid&&(
// preserve item in case there are extra key:values within
t.start=i,t.length=a-i,n.push(t),r=a)}),n}
/**
       * @typedef Mark~validObject
       * @type {object}
       * @property {number} start - The start position within the composite value
       * @property {number} end - The calculated end position within the composite
       * value.
       * @property {boolean} valid - boolean value indicating that the start and
       * calculated end range is valid
       */
/**
       * Initial validation of ranges for markRanges. Preliminary checks are done
       * to ensure the start and length values exist and are not zero or non-
       * numeric
       * @param {Mark~rangeObject} range - the current range object
       * @param {number} last - last index of range
       * @return {Mark~validObject}
       * @access protected
       */},{key:"callNoMatchOnInvalidRanges",value:function(t,e){var n,r,o=!1;return t&&void 0!==t.start?(r=(n=parseInt(t.start,10))+parseInt(t.length,10),
// ignore overlapping values & non-numeric entries
this.isNumeric(t.start)&&this.isNumeric(t.length)&&r-e>0&&r-n>0?o=!0:(this.log("Ignoring invalid or overlapping range: "+"".concat(JSON.stringify(t))),this.opt.noMatch(t))):(this.log("Ignoring invalid range: ".concat(JSON.stringify(t))),this.opt.noMatch(t)),{start:n,end:r,valid:o}}
/**
       * Check valid range for markRanges. Check ranges with access to the context
       * string. Range values are double checked, lengths that extend the mark
       * beyond the string length are limitied and ranges containing only
       * whitespace are ignored
       * @param {Mark~rangeObject} range - the current range object
       * @param {number} originalLength - original length of the context string
       * @param {string} string - current content string
       * @return {Mark~validObject}
       * @access protected
       */},{key:"checkWhitespaceRanges",value:function(t,e,n){var r,o=!0,
// the max value changes after the DOM is manipulated
i=n.length,
// adjust offset to account for wrapped text node
a=e-i,s=parseInt(t.start,10)-a;
// make sure to stop at max
return(r=(s=s>i?i:s)+parseInt(t.length,10))>i&&(r=i,this.log("End range automatically set to the max value of ".concat(i))),s<0||r-s<0||s>i||r>i?(o=!1,this.log("Invalid range: ".concat(JSON.stringify(t))),this.opt.noMatch(t)):""===n.substring(s,r).replace(/\s+/g,"")&&(o=!1,
// whitespace only; even if wrapped it is not visible
this.log("Skipping whitespace only range: "+JSON.stringify(t)),this.opt.noMatch(t)),{start:s,end:r,valid:o}}
/**
       * @typedef Mark~getTextNodesDict
       * @type {object.<string>}
       * @property {string} value - The composite value of all text nodes
       * @property {object[]} nodes - An array of objects
       * @property {number} nodes.start - The start position within the composite
       * value
       * @property {number} nodes.end - The end position within the composite
       * value
       * @property {HTMLElement} nodes.node - The DOM text node element
       */
/**
       * Callback
       * @callback Mark~getTextNodesCallback
       * @param {Mark~getTextNodesDict}
       */
/**
       * Calls the callback with an object containing all text nodes (including
       * iframe text nodes) with start and end positions and the composite value
       * of them (string)
       * @param {Mark~getTextNodesCallback} cb - Callback
       * @access protected
       */},{key:"getTextNodes",value:function(t){var e=this,n="",r=[];this.iterator.forEachNode(NodeFilter.SHOW_TEXT,function(t){r.push({start:n.length,end:(n+=t.textContent).length,node:t})},function(t){return e.matchesExclude(t.parentNode)?NodeFilter.FILTER_REJECT:NodeFilter.FILTER_ACCEPT},function(){t({value:n,nodes:r})})}
/**
       * Checks if an element matches any of the specified exclude selectors. Also
       * it checks for elements in which no marks should be performed (e.g.
       * script and style tags) and optionally already marked elements
       * @param  {HTMLElement} el - The element to check
       * @return {boolean}
       * @access protected
       */},{key:"matchesExclude",value:function(t){return a.matches(t,this.opt.exclude.concat([
// ignores the elements itself, not their childrens (selector *)
"script","style","title","head","html"]))}
/**
       * Wraps the instance element and class around matches that fit the start and
       * end positions within the node
       * @param  {HTMLElement} node - The DOM text node
       * @param  {number} start - The position where to start wrapping
       * @param  {number} end - The position where to end wrapping
       * @return {HTMLElement} Returns the splitted text node that will appear
       * after the wrapped text node
       * @access protected
       */},{key:"wrapRangeInTextNode",value:function(t,e,n){var r=this.opt.element?this.opt.element:"mark",o=t.splitText(e),i=o.splitText(n-e),a=document.createElement(r);return a.setAttribute("data-markjs","true"),this.opt.className&&a.setAttribute("class",this.opt.className),a.textContent=o.textContent,o.parentNode.replaceChild(a,o),i}
/**
       * @typedef Mark~wrapRangeInMappedTextNodeDict
       * @type {object.<string>}
       * @property {string} value - The composite value of all text nodes
       * @property {object[]} nodes - An array of objects
       * @property {number} nodes.start - The start position within the composite
       * value
       * @property {number} nodes.end - The end position within the composite
       * value
       * @property {HTMLElement} nodes.node - The DOM text node element
       */
/**
       * Each callback
       * @callback Mark~wrapMatchesEachCallback
       * @param {HTMLElement} node - The wrapped DOM element
       * @param {number} lastIndex - The last matching position within the
       * composite value of text nodes
       */
/**
       * Filter callback
       * @callback Mark~wrapMatchesFilterCallback
       * @param {HTMLElement} node - The matching text node DOM element
       */
/**
       * Determines matches by start and end positions using the text node
       * dictionary even across text nodes and calls
       * {@link Mark#wrapRangeInTextNode} to wrap them
       * @param  {Mark~wrapRangeInMappedTextNodeDict} dict - The dictionary
       * @param  {number} start - The start position of the match
       * @param  {number} end - The end position of the match
       * @param  {Mark~wrapMatchesFilterCallback} filterCb - Filter callback
       * @param  {Mark~wrapMatchesEachCallback} eachCb - Each callback
       * @access protected
       */},{key:"wrapRangeInMappedTextNode",value:function(t,e,n,r,o){var i=this;
// iterate over all text nodes to find the one matching the positions
t.nodes.every(function(a,s){var c=t.nodes[s+1];if(void 0===c||c.start>e){if(!r(a.node))return!1;
// map range from dict.value to text node
var u=e-a.start,l=(n>a.end?a.end:n)-a.start,h=t.value.substr(0,a.start),f=t.value.substr(l+a.start);if(a.node=i.wrapRangeInTextNode(a.node,u,l),
// recalculate positions to also find subsequent matches in the
// same text node. Necessary as the text node in dict now only
// contains the splitted part after the wrapped one
t.value=h+f,t.nodes.forEach(function(e,n){n>=s&&(t.nodes[n].start>0&&n!==s&&(t.nodes[n].start-=l),t.nodes[n].end-=l)}),n-=l,o(a.node.previousSibling,a.start),!(n>a.end))return!1;e=a.end}return!0})}
/**
      * @param {HTMLElement} node - The text node where the match occurs
      * @param {number} pos - The current position of the match within the node
      * @param {number} len - The length of the current match within the node
      * @param {Mark~wrapMatchesEachCallback} eachCb
      */},{key:"wrapGroups",value:function(t,e,n,r){return r((t=this.wrapRangeInTextNode(t,e,e+n)).previousSibling),t}
/**
       * Separate groups
       * @param {HTMLElement} node - The text node where the match occurs
       * @param {array} match - The current match
       * @param {number} matchIdx - The start of the match based on ignoreGroups
       * @param {Mark~wrapMatchesFilterCallback} filterCb
       * @param {Mark~wrapMatchesEachCallback} eachCb
       */},{key:"separateGroups",value:function(t,e,n,r,o){for(var i=e.length,a=1;a<i;a++){var s=t.textContent.indexOf(e[a]);e[a]&&s>-1&&r(e[a],t)&&(t=this.wrapGroups(t,s,e[a].length,o))}return t}
/**
       * Filter callback before each wrapping
       * @callback Mark~wrapMatchesFilterCallback
       * @param {string} match - The matching string
       * @param {HTMLElement} node - The text node where the match occurs
       */
/**
       * Callback for each wrapped element
       * @callback Mark~wrapMatchesEachCallback
       * @param {HTMLElement} element - The marked DOM element
       */
/**
       * Callback on end
       * @callback Mark~wrapMatchesEndCallback
       */
/**
       * Wraps the instance element and class around matches within single HTML
       * elements in all contexts
       * @param {RegExp} regex - The regular expression to be searched for
       * @param {number} ignoreGroups - A number indicating the amount of RegExp
       * matching groups to ignore
       * @param {Mark~wrapMatchesFilterCallback} filterCb
       * @param {Mark~wrapMatchesEachCallback} eachCb
       * @param {Mark~wrapMatchesEndCallback} endCb
       * @access protected
       */},{key:"wrapMatches",value:function(t,e,n,r,o){var i=this,a=0===e?0:e+1;this.getTextNodes(function(e){e.nodes.forEach(function(e){var o;for(e=e.node;null!==(o=t.exec(e.textContent))&&""!==o[a];){if(i.opt.separateGroups&&1!==o.length)e=i.separateGroups(e,o,a,n,r);else{if(!n(o[a],e))continue;var s=o.index;if(0!==a)for(var c=1;c<a;c++)s+=o[c].length;e=i.wrapGroups(e,s,o[a].length,r)}
// reset index of last match as the node changed and the
// index isn't valid anymore http://tinyurl.com/htsudjd
t.lastIndex=0}}),o()})}
/**
       * Callback for each wrapped element
       * @callback Mark~wrapMatchesAcrossElementsEachCallback
       * @param {HTMLElement} element - The marked DOM element
       */
/**
       * Filter callback before each wrapping
       * @callback Mark~wrapMatchesAcrossElementsFilterCallback
       * @param {string} match - The matching string
       * @param {HTMLElement} node - The text node where the match occurs
       */
/**
       * Callback on end
       * @callback Mark~wrapMatchesAcrossElementsEndCallback
       */
/**
       * Wraps the instance element and class around matches across all HTML
       * elements in all contexts
       * @param {RegExp} regex - The regular expression to be searched for
       * @param {number} ignoreGroups - A number indicating the amount of RegExp
       * matching groups to ignore
       * @param {Mark~wrapMatchesAcrossElementsFilterCallback} filterCb
       * @param {Mark~wrapMatchesAcrossElementsEachCallback} eachCb
       * @param {Mark~wrapMatchesAcrossElementsEndCallback} endCb
       * @access protected
       */},{key:"wrapMatchesAcrossElements",value:function(t,e,n,r,o){var i=this,a=0===e?0:e+1;this.getTextNodes(function(e){for(var s;null!==(s=t.exec(e.value))&&""!==s[a];){
// calculate range inside dict.value
var c=s.index;if(0!==a)for(var u=1;u<a;u++)c+=s[u].length;var l=c+s[a].length;
// note that dict will be updated automatically, as it'll change
// in the wrapping process, due to the fact that text
// nodes will be splitted
i.wrapRangeInMappedTextNode(e,c,l,function(t){return n(s[a],t)},function(e,n){t.lastIndex=n,r(e)})}o()})}
/**
       * Callback for each wrapped element
       * @callback Mark~wrapRangeFromIndexEachCallback
       * @param {HTMLElement} element - The marked DOM element
       * @param {Mark~rangeObject} range - the current range object; provided
       * start and length values will be numeric integers modified from the
       * provided original ranges.
       */
/**
       * Filter callback before each wrapping
       * @callback Mark~wrapRangeFromIndexFilterCallback
       * @param {HTMLElement} node - The text node which includes the range
       * @param {Mark~rangeObject} range - the current range object
       * @param {string} match - string extracted from the matching range
       * @param {number} counter - A counter indicating the number of all marks
       */
/**
       * Callback on end
       * @callback Mark~wrapRangeFromIndexEndCallback
       */
/**
       * Wraps the indicated ranges across all HTML elements in all contexts
       * @param {Mark~setOfRanges} ranges
       * @param {Mark~wrapRangeFromIndexFilterCallback} filterCb
       * @param {Mark~wrapRangeFromIndexEachCallback} eachCb
       * @param {Mark~wrapRangeFromIndexEndCallback} endCb
       * @access protected
       */},{key:"wrapRangeFromIndex",value:function(t,e,n,r){var o=this;this.getTextNodes(function(i){var a=i.value.length;t.forEach(function(t,r){var s=o.checkWhitespaceRanges(t,a,i.value),c=s.start,u=s.end;s.valid&&o.wrapRangeInMappedTextNode(i,c,u,function(n){return e(n,t,i.value.substring(c,u),r)},function(e){n(e,t)})}),r()})}
/**
       * Unwraps the specified DOM node with its content (text nodes or HTML)
       * without destroying possibly present events (using innerHTML) and normalizes
       * the parent at the end (merge splitted text nodes)
       * @param  {HTMLElement} node - The DOM node to unwrap
       * @access protected
       */},{key:"unwrapMatches",value:function(t){for(var e=t.parentNode,n=document.createDocumentFragment();t.firstChild;)n.appendChild(t.removeChild(t.firstChild));e.replaceChild(n,t),this.ie?
// custom method (needs more time)
this.normalizeTextNode(e):
// use browser's normalize method
e.normalize()}
/**
       * Normalizes text nodes. It's a workaround for the native normalize method
       * that has a bug in IE (see attached link). Should only be used in IE
       * browsers as it's slower than the native method.
       * @see {@link http://tinyurl.com/z5asa8c}
       * @param {HTMLElement} node - The DOM node to normalize
       * @access protected
       */},{key:"normalizeTextNode",value:function(t){if(t){if(3===t.nodeType)for(;t.nextSibling&&3===t.nextSibling.nodeType;)t.nodeValue+=t.nextSibling.nodeValue,t.parentNode.removeChild(t.nextSibling);else this.normalizeTextNode(t.firstChild);this.normalizeTextNode(t.nextSibling)}}
/**
       * Callback for each marked element
       * @callback Mark~markEachCallback
       * @param {HTMLElement} element - The marked DOM element
       */
/**
       * Callback if there were no matches
       * @callback Mark~markNoMatchCallback
       * @param {RegExp} term - The search term that was not found
       */
/**
       * Callback when finished
       * @callback Mark~commonDoneCallback
       * @param {number} totalMatches - The number of marked elements
       */
/**
       * @typedef Mark~commonOptions
       * @type {object.<string>}
       * @property {string} [element="mark"] - HTML element tag name
       * @property {string} [className] - An optional class name
       * @property {string[]} [exclude] - An array with exclusion selectors.
       * Elements matching those selectors will be ignored
       * @property {boolean} [iframes=false] - Whether to search inside iframes
       * @property {number} [iframesTimeout=5000] - Maximum ms to wait for a load
       * event of an iframe
       * @property {boolean} [acrossElements=false] - Whether to find matches
       * across HTML elements. By default, only matches within single HTML
       * elements will be found
       * @property {Mark~markEachCallback} [each]
       * @property {Mark~markNoMatchCallback} [noMatch]
       * @property {Mark~commonDoneCallback} [done]
       * @property {boolean} [debug=false] - Whether to log messages
       * @property {object} [log=window.console] - Where to log messages (only if
       * debug is true)
       */
/**
       * Callback if there were no matches
       * @callback Mark~markRegExpNoMatchCallback
       * @param {RegExp} regexp - The regular expression
       */
/**
       * Callback to filter matches
       * @callback Mark~markRegExpFilterCallback
       * @param {HTMLElement} textNode - The text node which includes the match
       * @param {string} match - The matching string for the RegExp
       * @param {number} counter - A counter indicating the number of all marks
       */
/**
       * These options also include the common options from
       * {@link Mark~commonOptions}
       * @typedef Mark~markRegExpOptions
       * @type {object.<string>}
       * @property {number} [ignoreGroups=0] - A number indicating the amount of
       * RegExp matching groups to ignore
       * @property {boolean} [separateGroups] - Whether to mark each regular
       * expression group as a separate match
       * @property {Mark~markRegExpNoMatchCallback} [noMatch]
       * @property {Mark~markRegExpFilterCallback} [filter]
       */
/**
       * Marks a custom regular expression
       * @param  {RegExp} regexp - The regular expression
       * @param  {Mark~markRegExpOptions} [opt] - Optional options object
       * @access public
       */},{key:"markRegExp",value:function(t,e){var n=this;this.opt=e,this.log('Searching with expression "'.concat(t,'"'));var r=0,o="wrapMatches";this.opt.acrossElements&&(o="wrapMatchesAcrossElements"),this[o](t,this.opt.ignoreGroups,function(t,e){return n.opt.filter(e,t,r)},function(t){r++,n.opt.each(t)},function(){0===r&&n.opt.noMatch(t),n.opt.done(r)})}
/**
       * Callback to filter matches
       * @callback Mark~markFilterCallback
       * @param {HTMLElement} textNode - The text node which includes the match
       * @param {string} match - The matching term
       * @param {number} totalCounter - A counter indicating the number of all
       * marks
       * @param {number} termCounter - A counter indicating the number of marks
       * for the specific match
       */
/**
       * These options also include the common options from
       * {@link Mark~commonOptions} and the options from
       * {@link RegExpCreator~options}
       * @typedef Mark~markOptions
       * @type {object.<string>}
       * @property {boolean} [separateWordSearch=true] - Whether to search for
       * each word separated by a blank instead of the complete term
       * @property {Mark~markFilterCallback} [filter]
       */
/**
       * Marks the specified search terms
       * @param {string|string[]} [sv] - Search value, either a search string or an
       * array containing multiple search strings
       * @param  {Mark~markOptions} [opt] - Optional options object
       * @access public
       */},{key:"mark",value:function(t,e){var n=this;this.opt=e;var r=0,o="wrapMatches",i=this.getSeparatedKeywords("string"==typeof t?[t]:t),a=i.keywords,c=i.length;this.opt.acrossElements&&(o="wrapMatchesAcrossElements"),0===c?this.opt.done(r):function t(e){
// async function calls as iframes are async too
var i=new s(n.opt).create(e),u=0;n.log('Searching with expression "'.concat(i,'"')),n[o](i,1,function(t,o){return n.opt.filter(o,e,r,u)},function(t){u++,r++,n.opt.each(t)},function(){0===u&&n.opt.noMatch(e),a[c-1]===e?n.opt.done(r):t(a[a.indexOf(e)+1])})}(a[0])}
/**
       * Callback for each marked element
       * @callback Mark~markRangesEachCallback
       * @param {HTMLElement} element - The marked DOM element
       * @param {array} range - array of range start and end points
       */
/**
       * Callback if a processed range is invalid, out-of-bounds, overlaps another
       * range, or only matches whitespace
       * @callback Mark~markRangesNoMatchCallback
       * @param {Mark~rangeObject} range - a range object
       */
/**
       * Callback to filter matches
       * @callback Mark~markRangesFilterCallback
       * @param {HTMLElement} node - The text node which includes the range
       * @param {array} range - array of range start and end points
       * @param {string} match - string extracted from the matching range
       * @param {number} counter - A counter indicating the number of all marks
       */
/**
       * These options also include the common options from
       * {@link Mark~commonOptions} without the each and noMatch callback
       * @typedef Mark~markRangesOptions
       * @type {object.<string>}
       * @property {Mark~markRangesEachCallback} [each]
       * @property {Mark~markRangesNoMatchCallback} [noMatch]
       * @property {Mark~markRangesFilterCallback} [filter]
       */
/**
       * Marks an array of objects containing a start with an end or length of the
       * string to mark
       * @param  {Mark~setOfRanges} rawRanges - The original (preprocessed)
       * array of objects
       * @param  {Mark~markRangesOptions} [opt] - Optional options object
       * @access public
       */},{key:"markRanges",value:function(t,e){var n=this;this.opt=e;var r=0,o=this.checkRanges(t);o&&o.length?(this.log("Starting to mark with the following ranges: "+JSON.stringify(o)),this.wrapRangeFromIndex(o,function(t,e,r,o){return n.opt.filter(t,e,r,o)},function(t,e){r++,n.opt.each(t,e)},function(){n.opt.done(r)})):this.opt.done(r)}
/**
       * Removes all marked elements inside the context with their HTML and
       * normalizes the parent at the end
       * @param  {Mark~commonOptions} [opt] - Optional options object without each,
       * noMatch and acrossElements properties
       * @access public
       */},{key:"unmark",value:function(t){var e=this;this.opt=t;var n=this.opt.element?this.opt.element:"*";n+="[data-markjs]",this.opt.className&&(n+=".".concat(this.opt.className)),this.log('Removal selector "'.concat(n,'"')),this.iterator.forEachNode(NodeFilter.SHOW_ELEMENT,function(t){e.unwrapMatches(t)},function(t){var r=a.matches(t,n),o=e.matchesExclude(t);return!r||o?NodeFilter.FILTER_REJECT:NodeFilter.FILTER_ACCEPT},this.opt.done)}}]),t}();return t.fn.mark=function(t,e){return new c(this.get()).mark(t,e),this},t.fn.markRegExp=function(t,e){return new c(this.get()).markRegExp(t,e),this},t.fn.markRanges=function(t,e){return new c(this.get()).markRanges(t,e),this},t.fn.unmark=function(t){return new c(this.get()).unmark(t),this},t});
